#' @export
#' @title Add souporcell clustering file output to a seurat object
#' @description This function takes as input a seurat object and the location of a souporcell file (clusters.tsv).  The function will add
#' an assay to the seurat object such that the reduced dimensions of said assay are the principal components of the log of the cluster probabilities
#' returned by souporcell in the clusters.tsv file.  These cluster probabalities are normalized by the mean before log transformation and PCA.
#' The souporcell 'assignment' is added to the seurat metadata using the meta_data_label argument.  Name of the dimensionality reduction can be set
#' using the rd_label argument, accompanying key is set with the key argument and the assay name is set using assay_name.  Use of the rename_assignments
#' parameter will set the genotype numbering to 1-indexed (instead of the 0-indexed souporcell output) and will collapse all genotype 
#' multiplet designations (0/1, 1/0, 0/2, 2/0, etc) to "multiplet".  This feature is turned off by setting rename_assignments to F.
#'
#' @returns a seurat object with a reduced dimension assay containing the SNP clusters as generated by souporcell but modified as discussed above.
#'A column is added to the meta data as designated by the meta_data_label argument with the genotype assignment generated by souporcell
#'
#' @param obj input Seurat object
#' @param souporcell_file location of souporcell clusters.tsv file
#' @param assay_name name of assay object
#' @param prefix optional prefix to prepend cell barcodes
#' @param key name of key to use
#' @param meta_data_label name of the column in the returned meta data to place the souporcell assignment.  Does not check for overwriting
#' @param rd_label name of the dimensionality reduction
#' @param rename_assignment rename souporcell assignment as discussed in the description
#' @importFrom Seurat CreateAssayObject
#' @importFrom Seurat CreateDimReducObject

add_souporcell_seurat<-function(obj, souporcell_file, prefix=NULL, assay_name="GENO", key = "gpca_", meta_data_label="geno", rd_label="gpca", rename_assignments=T){
  #check to see if file exists
  if(length(souporcell_file)>1){stop("only supports one file addition at a time")}
  if(!file.exists(souporcell_file)){stop("Souporcell file does not exist!")}
  
  #check that obj is seurat
  if(!class(obj)=="Seurat"){stop("object does not appear to be of the Seurat class")}
  
  ctsv<-read.table(souporcell_file, header = T)
  
  #check to make sure this has all the bits
  if(!all(c("barcode","status","assignment","log_prob_singleton","log_prob_doublet") %in% colnames(ctsv))){stop(paste0("souporcell file: ", souporcell_file, " does not have the right stuff!"))}
  
  if(is.null(prefix)){
    rownames(ctsv)<-ctsv$barcode
  } else {
    rownames(ctsv) <-paste0(prefix[1], ctsv$barcode)
  }
  
  if(!all(Cells(obj) %in% rownames(ctsv))) {stop("not all cells in object found in souporcell data")}
  ctsv<-ctsv[Cells(obj),]
  cs<-as.matrix(ctsv[,colnames(ctsv)[grep("^cluster", colnames(ctsv))]])
  cs<-as.data.frame(log10(sweep(cs, 2, colMeans(cs), "/")))
  pc<-stats::princomp(cs)
  pcv<-as.data.frame(pc$scores)
  pcv$barcode<-ctsv$barcode
  pcv$assignment<-ctsv$assignment
  if(rename_assignments) {
    pcv$fixed_assignment<-fix_assignment(pcv$assignment)
  } else {
    pcv$fixed_assignment<-pcv$assignment
  }
  pcv$status<-ctsv$status
  obj[[assay_name]]<-CreateAssayObject(data = t(as.matrix(cs)), )
  DefaultAssay(obj)<-assay_name
  obj[[rd_label]] <- CreateDimReducObject(embeddings = as.matrix(pcv[,1:ncol(cs)]), key = key, assay = assay_name)
  obj[[meta_data_label]]<-"Not_Calculated"
  obj@meta.data[pcv$barcode,][[meta_data_label]]<-pcv$fixed_assignment
  obj@meta.data<-obj@meta.data[Cells(obj),]
  obj
}



## helper for add_souporcell_seurat function
fix_assignment<-function(vector){
  # vector[vector=="1"]<-"2"
  # vector[vector=="0"]<-"1"
  vector[grepl("\\/", vector)]<-"Multiplet"
  vector[!vector=="Multiplet"]<-as.numeric(vector[!vector=="Multiplet"])+1
  vector
}



#' @export
#' @title Finds common features in a list of single cell objects
#'
#' @description Machine learning algorithms often require features to be the same across 
#' datasets.  This function finds common features between a list of cell data set objects (monocle3) and 
#' returns a list of cds's that have the same features.  Note that this function uses rownames 
#' of the 'fData' DataFrame (monocle3) and the rownames of the seurat_object to find the intersect of features common to all objects
#'
#' @param cds_list Input  object.
#' @export
common_features <- function(cds_list){
  len<-length(cds_list)
  common_features=vector()
  software<-NULL
  for(i in 1:len){
    if(i < 2){
      if(class(cds_list[[i]])=="Seurat"){software<-"seurat"}
      if(class(cds_list[[i]])=="cell_data_set"){software<-"monocle3"}
      if(is.null(software)){stop("software not found for input object 1")}
      if(software=="monocle3"){
        common_features<-rownames(fData(cds_list[[i]]))
      }
      if(software=="seurat"){
        common_features<-rownames(cds_list[[i]])
      }
    }else{
      if(software=="monocle3"){
        common_features<-unique(intersect(common_features, rownames(fData(cds_list[[i]]))))
      }
      if(software=="seurat"){
        common_features<-unique(intersect(common_features, rownames(cds_list[[i]])))
      }
    }
  }
  if(software=="monocle3"){
    for(i in 1:len){
      cds_list[[i]]<-cds_list[[i]][match(common_features, rownames(cds_list[[i]])),]
    }
    return(cds_list)
  }
  if(software=="seurat"){
    for(i in 1:len){
      mat<-cds_list[[i]]@assays[[cds_list[[i]]@active.assay]]@counts
      seutmp<- CreateSeuratObject(counts = mat[common_features, ]) # Create a new Seurat object with just the genes of interest
      cds_list[[i]] <- AddMetaData(object = seutmp, metadata = cds_list[[i]]@meta.data) # Add the idents to the meta.data slot
      rm(seutmp, mat)
    }
    return(cds_list)
  }
}



#' Performs TF-IDF transformation on a cell_data_set
#'
#' @description Just like it sounds.
#'
#' @param cds_list Input cell_data_set object or sparse matrix.
#' @importFrom Matrix rowSums
#' @importFrom Matrix colSums
#' @importFrom Matrix Diagonal
#' @importFrom Matrix t
#' @export
#' @keywords internal
tf_idf_transform <- function(input, method=1, verbose=T){
  if(class(input)=="cell_data_set"){
    mat<-exprs(input)
  }else{
    mat<-input
  }
  rn <- rownames(mat)
  row_sums<-rowSums(mat)
  nz<-which(row_sums>0)
  mat <- mat[nz,]
  rn <- rn[nz]
  row_sums <- row_sums[nz]
  col_sums <- colSums(mat)
  
  #column normalize
  mat <-Matrix::t(Matrix::t(mat)/col_sums)
  
  
  if (method == 1) {
    #Adapted from Casanovich et al.
    if(verbose) message("Computing Inverse Document Frequency")
    idf   <- as(log(1 + ncol(mat) / row_sums), "sparseVector")
    if(verbose) message("Computing TF-IDF Matrix")
    mat <- as(Diagonal(x = as.vector(idf)), "sparseMatrix") %*% 
      mat
  }
  else if (method == 2) {
    #Adapted from Stuart et al.
    if(verbose) message("Computing Inverse Document Frequency")
    idf   <- as( ncol(mat) / row_sums, "sparseVector")
    if(verbose) message("Computing TF-IDF Matrix")
    mat <- as(Diagonal(x = as.vector(idf)), "sparseMatrix") %*% 
      mat
    mat@x <- log(mat@x * scale_to + 1)
  }else if (method == 3) {
    mat@x <- log(mat@x + 1)
    if(verbose) message("Computing Inverse Document Frequency")
    idf <- as(log(1 + ncol(mat) /row_sums), "sparseVector")
    if(verbose) message("Computing TF-IDF Matrix")
    mat <- as(Diagonal(x = as.vector(idf)), "sparseMatrix") %*% 
      mat
  }else {
    stop("LSIMethod unrecognized please select valid method!")
  }
  rownames(mat) <- rn
  if(class(input)=="cell_data_set"){
    input@assays$data$counts<-mat
    return(input)
  }else{
    return(mat)
  }
}

#' Performs TF-IDF transformation on a cell_data_set v2
#'
#' @description Just like it sounds but different.
#'
#' @param cds_list Input cell_data_set object or sparse matrix.
#' @importFrom Matrix rowSums
#' @importFrom Matrix colSums
#' @importFrom Matrix Diagonal
#' @importFrom irlba irlba
#' @export
#' @keywords internal
tf_idf_transform_v2 <- function(input){
  if(class(input)=="cell_data_set"){
    mat<-exprs(input)
  }else{
    mat<-input
  }
  colSm <- colSums(mat)
  rowSm <- rowSums(mat)
  freqs <- t(t(mat)/colSm)
  idf   <- as(log(1 + ncol(mat) / rowSm), "sparseVector")
  tfidf <- as(Diagonal(x=as.vector(idf)), "sparseMatrix") %*% freqs
  tfidf@x[is.na(tfidf@x)] <- 0
  if(class(input)=="cell_data_set"){
    input@assays$data$counts<-tfidf
    return(input)
  }else{
    return(tfidf)
  }
}

#' @export
svd_lsi<-function(sp_mat, num_dim, mat_only=T){
  svd <- irlba(sp_mat, num_dim, num_dim)
  svdDiag <- matrix(0, nrow=num_dim, ncol=num_dim)
  diag(svdDiag) <- svd$d
  matSVD <- t(svdDiag %*% t(svd$v))
  rownames(matSVD) <- colnames(sp_mat)
  colnames(matSVD) <- seq_len(ncol(matSVD))
  if(mat_only){
    return(matSVD)
  }else{
    return(list(matSVD=matSVD, svd=svd))
  }
}


Noisify <- function(data, amount=0.0001) {
  if (is.vector(data)) {
    noise <- runif(length(data), -amount, amount)
    noisified <- data + noise
  } else {
    length <- dim(data)[1] * dim(data)[2]
    noise <- matrix(runif(length, -amount, amount), dim(data)[1])
    noisified <- data + noise
  }
  return(noisified)
}


#' Detects genes above minimum threshold.
#'
#' @description For each gene in a cell_data_set object, detect_genes counts
#' how many cells are expressed above a minimum threshold. In addition, for
#' each cell, detect_genes counts the number of genes above this threshold that
#' are detectable. Results are added as columns num_cells_expressed and
#' num_genes_expressed in the rowData and colData tables respectively.
#'
#' @param cds Input cell_data_set object.
#' @param min_expr Numeric indicating expression threshold
#' @param exprs_bin Boolean whether to bin genes by mean expression
#' @param exprs_cuts Numeic indicating number of bins if using exprs_bin
#' @return Updated cell_data_set object
#' @importFrom Hmisc cut2
#' @importFrom assertthat assert_that
#' @importFrom Matrix rowSums
#' @importFrom Matrix colSums
#' @importFrom Matrix rowMeans
#' @importFrom SingleCellExperiment counts
#' @export
#' @keywords internal
detect_genes <- function(cds, min_expr=0, exprs_bin=TRUE, exprs_cuts=25){
  assert_that(methods::is(cds, "cell_data_set"))
  assert_that(is.numeric(min_expr))
  
  rowData(cds)$num_cells_expressed <- rowSums((cds) > min_expr)
  colData(cds)$num_genes_expressed <- colSums(counts(cds) > min_expr)
  if(exprs_bin){
    fData(cds)$exprs_bin = cut2(log(rowMeans(normalized_counts(cds))), m=floor(nrow(fData(cds))/exprs_cuts))
  }
  cds
}


#' Convert a GMT File to a ragged list of genes
#'
#' @description GMT Files (See MSigDB) are a convenient means of storing genesets
#'
#' @param GMTfn GMT filename
#' @export
#' @keywords internal
GMT_to_list<-function (GMTfn) 
{
  file.data <- readLines(GMTfn)
  num.lines <- length(file.data)
  output <- vector("list", num.lines)
  for (i in 1:num.lines) {
    vec <- unlist(strsplit(file.data[i], "\t"))
    output[[i]] <- vec[3:length(vec)]
    names(output)[i] <- vec[1]
  }
  return(output)
}

#' @export
bimodality_coefficient<-function(x, finite=TRUE,...){
  if(finite==TRUE){
    G=skewness(x,finite)
    sample.excess.kurtosis=kurtosis(x,finite)
    K=sample.excess.kurtosis
    n=length(x)
    B=((G^2)+1)/(K+ ((3*((n-1)^2))/((n-2)*(n-3))))
  }
  else{
    G=skewness(x,FALSE)
    K=kurtosis(x,FALSE)
    B=((G^2)+1)/(K)
  }
  return(B)
}

#' @export
skewness<-function(x, finite=TRUE){
  n=length(x)
  S=(1/n)*sum((x-mean(x))^3)/(((1/n)*sum((x-mean(x))^2))^1.5)
  if(finite==FALSE){
    S=S
  }else{
    S=S*(sqrt(n*(n-1)))/(n-2)
  }
  return(S)	
}

#' @export
kurtosis<-function(x, finite){
  n=length(x)
  K=(1/n)*sum((x-mean(x))^4)/(((1/n)*sum((x-mean(x))^2))^2) - 3
  if(finite==FALSE){
    K=K
  }
  else{
    K=((n-1)*((n+1)*K - 3*(n-1))/((n-2)*(n-3))) +3
  }
  return(K)	
}

#' @export

lighten_darken_color<-function(col, amt) {
  if (substring(col, 1, 1)=="#") {
    col = substring(col, 2)
  }
  num = as.hexmode(col)
  r = bitwShiftR(num, 16) + amt
  if (r > 255) {r = 255}
  if  (r < 0) {r = 0}
  b = bitwAnd(bitwShiftR(num, 8), 0x00FF) + amt
  if (b > 255) {b = 255}
  if  (b < 0) {b = 0}
  g = bitwAnd(num, 0x0000FF) + amt
  if (g > 255) {g = 255}
  if (g < 0) {g = 0}
  inter<-paste("000000", as.hexmode(bitwOr(g , bitwOr(bitwShiftL(b, 8), bitwShiftL(r, 16)))), sep="")
  ret<-substr(inter, nchar(inter)-5, nchar(inter))
  return(toupper(paste("#", ret, sep="")))
}

#' @export
#' @importFrom assertthat assert_that
#' @importFrom tibble rownames_to_column
#' @importFrom dplyr filter
mean_gene_expression<-function (cds, markers, group_cells_by = "cluster", reduction_method = "UMAP", 
                                norm_method = c("log", "size_only"), lower_threshold = 0, 
                                max.size = 10, ordering_type = c("cluster_row_col", "maximal_on_diag", 
                                                                 "none"), axis_order = c("group_marker", "marker_group"), 
                                flip_percentage_mean = FALSE, pseudocount = 1, scale_max = 3, 
                                scale_min = -3) 
{
  assert_that(methods::is(cds, "cell_data_set"))
  if (!is.null(group_cells_by)) {
    assert_that(group_cells_by %in% c("cluster", 
                                                  "partition") | group_cells_by %in% names(colData(cds)), 
                            msg = paste("group_cells_by must be a column in", 
                                        "the colData table."))
  }
  assert_that("gene_short_name" %in% names(rowData(cds)), 
                          msg = paste("This function requires a gene_short_name", 
                                      "column in your rowData. If you do not have", "gene symbols, you can use other gene ids", 
                                      "by running", "rowData(cds)$gene_short_name <- row.names(rowData(cds))"))
  norm_method = match.arg(norm_method)
  gene_ids = as.data.frame(fData(cds)) %>% rownames_to_column() %>% 
    filter(rowname %in% markers | gene_short_name %in% 
                    markers) %>% dplyr::pull(rowname)
  if (length(gene_ids) < 1) 
    stop(paste("Please make sure markers are included in the gene_short_name\",\n               \"column of the rowData!"))
  if (flip_percentage_mean == FALSE) {
    major_axis <- 1
    minor_axis <- 2
  }
  else if (flip_percentage_mean == TRUE) {
    major_axis <- 2
    minor_axis <- 1
  }
  exprs_mat <- t(as.matrix(exprs(cds)[gene_ids, ]))
  exprs_mat <- reshape2::melt(exprs_mat)
  colnames(exprs_mat) <- c("Cell", "Gene", "Expression")
  exprs_mat$Gene <- as.character(exprs_mat$Gene)
  if (group_cells_by == "cluster") {
    cell_group <- tryCatch({
      clusters(cds, reduction_method = reduction_method)
    }, error = function(e) {
      NULL
    })
  }
  else if (group_cells_by == "partition") {
    cell_group <- tryCatch({
      partitions(cds, reduction_method = reduction_method)
    }, error = function(e) {
      NULL
    })
  }
  else {
    cell_group <- colData(cds)[, group_cells_by]
  }
  if (length(unique(cell_group)) < 2) {
    stop(paste("Only one type in group_cells_by. To use plot_genes_by_group,", 
               "please specify a group with more than one type. "))
  }
  names(cell_group) = colnames(cds)
  exprs_mat$Group <- cell_group[exprs_mat$Cell]
  exprs_mat = exprs_mat %>% dplyr::filter(is.na(Group) == FALSE)
  ExpVal <- exprs_mat %>% dplyr::group_by(Group, Gene) %>% 
    dplyr::summarize(mean = mean(log(Expression + pseudocount)), 
                     percentage = sum(Expression > lower_threshold)/length(Expression))
  ExpVal$mean <- ifelse(ExpVal$mean < scale_min, scale_min, 
                        ExpVal$mean)
  ExpVal$mean <- ifelse(ExpVal$mean > scale_max, scale_max, 
                        ExpVal$mean)
  ExpVal$Gene <- fData(cds)[ExpVal$Gene, "gene_short_name"]
  res <- reshape2::dcast(ExpVal[, 1:4], Group ~ Gene, value.var = colnames(ExpVal)[2 + 
                                                                                     major_axis])
  group_id <- res[, 1]
  out<-t(res[, -1])
  rownames(out)<-colnames(res[, -1])
  colnames(out)<-res$Group
  out
}


plot_genes_by_group<-function (cds, markers, group_cells_by = "cluster", reduction_method = "UMAP", 
                               norm_method = c("log", "size_only"), lower_threshold = 0, 
                               max.size = 10, ordering_type = c("cluster_row_col", "maximal_on_diag", 
                                                                "none"), axis_order = c("group_marker", "marker_group"), 
                               flip_percentage_mean = FALSE, scale_row=T, pseudocount = 1, scale_max = 3, 
                               scale_min = -3) 
{
  assertthat::assert_that(methods::is(cds, "cell_data_set"))
  if (!is.null(group_cells_by)) {
    assertthat::assert_that(group_cells_by %in% c("cluster", 
                                                  "partition") | group_cells_by %in% names(colData(cds)), 
                            msg = paste("group_cells_by must be a column in", 
                                        "the colData table."))
  }
  assertthat::assert_that("gene_short_name" %in% names(rowData(cds)), 
                          msg = paste("This function requires a gene_short_name", 
                                      "column in your rowData. If you do not have", "gene symbols, you can use other gene ids", 
                                      "by running", "rowData(cds)$gene_short_name <- row.names(rowData(cds))"))
  norm_method = match.arg(norm_method)
  gene_ids = as.data.frame(fData(cds)) %>% tibble::rownames_to_column() %>% 
    dplyr::filter(rowname %in% markers | gene_short_name %in% 
                    markers) %>% dplyr::pull(rowname)
  if (length(gene_ids) < 1) 
    stop(paste("Please make sure markers are included in the gene_short_name\",\n               \"column of the rowData!"))
  if (flip_percentage_mean == FALSE) {
    major_axis <- 1
    minor_axis <- 2
  }
  else if (flip_percentage_mean == TRUE) {
    major_axis <- 2
    minor_axis <- 1
  }
  exprs_mat <- t(as.matrix(exprs(cds)[gene_ids, ]))
  exprs_mat <- reshape2::melt(exprs_mat)
  colnames(exprs_mat) <- c("Cell", "Gene", "Expression")
  exprs_mat$Gene <- as.character(exprs_mat$Gene)
  if (group_cells_by == "cluster") {
    cell_group <- tryCatch({
      clusters(cds, reduction_method = reduction_method)
    }, error = function(e) {
      NULL
    })
  }
  else if (group_cells_by == "partition") {
    cell_group <- tryCatch({
      partitions(cds, reduction_method = reduction_method)
    }, error = function(e) {
      NULL
    })
  }
  else {
    cell_group <- colData(cds)[, group_cells_by]
  }
  if (length(unique(cell_group)) < 2) {
    stop(paste("Only one type in group_cells_by. To use plot_genes_by_group,", 
               "please specify a group with more than one type. "))
  }
  names(cell_group) = colnames(cds)
  exprs_mat$Group <- cell_group[exprs_mat$Cell]
  exprs_mat = exprs_mat %>% dplyr::filter(is.na(Group) == FALSE)
  ExpVal <- exprs_mat %>% dplyr::group_by(Group, Gene) %>% 
    dplyr::summarize(mean = mean(log(Expression + pseudocount)), 
                     percentage = sum(Expression > lower_threshold)/length(Expression))
  ExpVal$mean <- ifelse(ExpVal$mean < scale_min, scale_min, 
                        ExpVal$mean)
  ExpVal$mean <- ifelse(ExpVal$mean > scale_max, scale_max, 
                        ExpVal$mean)
  ExpVal$Gene <- fData(cds)[ExpVal$Gene, "gene_short_name"]
  res <- reshape2::dcast(ExpVal[, 1:4], Group ~ Gene, value.var = colnames(ExpVal)[2 + 
                                                                                     major_axis])
  group_id <- res[, 1]
  res <- res[, -1]
  if(scale_row){
    res<-t(scale(t(res)))
  }
  row.names(res) <- group_id
  if (ordering_type == "cluster_row_col") {
    row_dist <- stats::as.dist((1 - stats::cor(t(res)))/2)
    row_dist[is.na(row_dist)] <- 1
    col_dist <- stats::as.dist((1 - stats::cor(res))/2)
    col_dist[is.na(col_dist)] <- 1
    ph <- pheatmap::pheatmap(res, useRaster = T, cluster_cols = TRUE, 
                             cluster_rows = TRUE, show_rownames = F, show_colnames = F, 
                             clustering_distance_cols = col_dist, clustering_distance_rows = row_dist, 
                             clustering_method = "ward.D2", silent = TRUE, filename = NA)
    ExpVal$Gene <- factor(ExpVal$Gene, levels = colnames(res)[ph$tree_col$order])
    ExpVal$Group <- factor(ExpVal$Group, levels = row.names(res)[ph$tree_row$order])
  }
  else if (ordering_type == "maximal_on_diag") {
    order_mat <- t(apply(res, major_axis, order))
    max_ind_vec <- c()
    for (i in 1:nrow(order_mat)) {
      tmp <- max(which(!(order_mat[i, ] %in% max_ind_vec)))
      max_ind_vec <- c(max_ind_vec, order_mat[i, tmp])
    }
    max_ind_vec <- max_ind_vec[!is.na(max_ind_vec)]
    if (major_axis == 1) {
      max_ind_vec <- c(max_ind_vec, setdiff(1:length(markers), 
                                            max_ind_vec))
      ExpVal$Gene <- factor(ExpVal$Gene, levels = dimnames(res)[[2]][max_ind_vec])
    }
    else {
      max_ind_vec <- c(max_ind_vec, setdiff(1:length(unique(exprs_mat$Group)), 
                                            max_ind_vec))
      ExpVal$Group <- factor(ExpVal$Group, levels = dimnames(res)[[1]][max_ind_vec])
    }
  }
  else if (ordering_type == "none") {
    ExpVal$Gene <- factor(ExpVal$Gene, levels = markers)
  }
  if (flip_percentage_mean) {
    g <- ggplot(ExpVal, aes(y = Gene, x = Group)) + geom_point(aes(colour = percentage, 
                                                                   size = mean)) + viridis::scale_color_viridis(name = "percentage") + 
      scale_size(name = "log(mean + 0.1)", range = c(0, 
                                                     max.size))
  }
  else {
    g <- ggplot(ExpVal, aes(y = Gene, x = Group)) + geom_point(aes(colour = mean, 
                                                                   size = percentage)) + viridis::scale_color_viridis(name = "log(mean + 0.1)") + 
      scale_size(name = "percentage", range = c(0, max.size))
  }
  if (group_cells_by == "cluster") {
    g <- g + xlab("Cluster")
  }
  else if (group_cells_by == "partition") {
    g <- g + xlab("Partition")
  }
  else {
    g <- g + xlab(group_cells_by)
  }
  g <- g + ylab("Gene") + monocle3:::monocle_theme_opts() + theme(axis.text.x = element_text(angle = 30, 
                                                                                             hjust = 1))
  if (axis_order == "marker_group") {
    g <- g + coord_flip()
  }
  g
}


#' Seurat to Monocle3
#' @description Conver Seurat to Monocle3
#' @param seu Seurat Object
#' @param seu_rd Reduced dimname for seurat ('i.e. UMAP'); use NULLto not copy dimensionality reduction
#' @param assay_name Name of data slot ('i.e. RNA')
#' @param mon_rd Reduced dimname for monocle3 ('i.e. UMAP'); use NULL to not copy dimensionality reduction
#' @import Seurat
#' @import monocle3
#' @return a cell_data_set object
#' @export


seurat_to_monocle3 <-function(seu, seu_rd="umap", mon_rd="UMAP", assay_name="RNA"){
  cds<-new_cell_data_set(seu@assays[[assay_name]]@counts, 
                         cell_metadata = seu@meta.data, 
                         gene_metadata = DataFrame(
                           row.names = rownames(seu@assays[[assay_name]]@counts), 
                           id=rownames(seu@assays[[assay_name]]@counts), 
                           gene_short_name=rownames(seu@assays[[assay_name]]@counts)))
  if(!is.null(seu_rd)){
    if(!is.null(mon_rd)){
      reducedDims(cds)[[mon_rd]]<-seu@reductions[[seu_rd]]@cell.embeddings
    }
  }
  cds
}

#' Monocle3 to Seurat
#' @description Conver Monocle3 cell data set to a Seurat object.  For a variety of reasons, the recommendations are to use this funciont
#' only to generate skeleton Seurat objects that can be used for plotting and not much else.  The resulting object will not contain PCA reducitons or 
#' nearest neighbor graphs.
#' @param seu Seurat Object
#' @param seu_rd Reduced dimname for seurat ('i.e. UMAP')
#' @param assay_name Name of data slot ('i.e. RNA')
#' @param mon_rd Reduced dimname for monocle3 ('i.e. UMAP')
#' @param row.names rowData column to use as rownames for Seurat object
#' @param duplicate_rownnames how to handle duplicate rownames
#' @import Seurat
#' @import monocle3
#' @import SingleCellExperiment
#' @importFrom Seurat CreateDimReducObject
#' @return a cell_data_set object
#' @export


monocle3_to_seurat <-function(cds, seu_rd="umap", mon_rd="UMAP", assay_name="RNA", row.names="gene_short_name", normalize=T, duplicate_rownames = c("rename", "remove")){
  warning("this function will create a Seurat object with only 1 reduced dimension; currently only UMAP is supported")
  duplicate_rownames <-match.arg(duplicate_rownames)
  counts <- exprs(cds)
  rownames(counts) <- rowData(cds)[[row.names]]
  if(duplicate_rownames=="remove"){
    counts<-counts[!duplicated(rownames(counts)),]
  } else {
    rownames(counts) <-make.unique(rownames(counts))
  }
  seu<-CreateSeuratObject(counts, meta.data = data.frame(colData(cds)))
  keyname<-paste0(seu_rd, "_")
  colnames(reducedDims(cds)[[mon_rd]])<-paste0(keyname, 1:dim(reducedDims(cds)[[mon_rd]])[2])
  seu@reductions[[seu_rd]]<-CreateDimReducObject(embeddings = reducedDims(cds)[[mon_rd]], key = keyname, assay = assay_name, )
  if(normalize){seu<-NormalizeData(seu)}
  seu
}

#' Make colors
#' @description This function creates a color palatte
#' @param n number of colors
#' @param scramble whether to jumble the colors
#' @export
sfc<-function(n, scramble=F){
  if(!n%%1==0)stop("Please input integer n")
  ar20<-c("#16482A", "#1C7C40", "#45AC49", "#69BC9A", "#FBD43F", "#E77A2B", "#DC3F32", "#932528", "#50191E", "#96C4D9", "#2394C4", "#4575AD", "#8681B0", "#6C5492", "#8C4A8D", "#9E2563", "#492C74","#E9E52F", "#F8C566", "#D85191")
  ar10<-ar20[c(1,3,5,7,9,11,13,15,17,20)]
  ar5<-ar10[c(1,3,6,9,10)]
  ar4<-ar10[c(2,4,6,8)]
  if(n>10)funct<-colorRampPalette(ar20)
  if(n<11 & n>4)funct<-colorRampPalette(ar10)
  if(n<5 & n>3)funct<-colorRampPalette(ar4)
  if(n<4)funct<-colorRampPalette(ar5)
  if(scramble){
    return(sample(funct(n),n))
  } else{
    return(funct(n))
  }
}

#' Write a compressed MatrixMarket file
#'
#' This function writes a sparse matrix in the MatrixMarket format to a compressed `.gz` file.
#' The function handles both real and integer matrix types.
#'
#' @param x A sparse matrix (typically a \code{dgCMatrix} or \code{ngCMatrix} object).
#' @param file A character string specifying the output file name, which will be compressed into `.gz` format.
#'
#' @details
#' This function writes the matrix in the MatrixMarket coordinate format. 
#' It first writes the header indicating the matrix type and size, and then appends the matrix data.
#' If the matrix is an `ngCMatrix`, it is treated as an integer matrix, otherwise as a real matrix.
#' The function compresses the output into a `.gz` file.
#'
#' @importFrom data.table fwrite
#' @importFrom Matrix summary
#'
#' @return This function does not return a value. It writes a file as a side effect.
#' @export
#' @examples
#' \dontrun{
#' library(Matrix)
#' m <- Matrix(c(0, 1, 0, 2), 2, 2, sparse = TRUE)
#' writeMMgz(m, "matrix.mtx.gz")
#' }
writeMMgz <- function(x, file) {
  mtype <- "real"
  if (is(x, "ngCMatrix")) {
    mtype <- "integer"
  }
  writeLines(
    c(
      sprintf("%%%%MatrixMarket matrix coordinate %s general", mtype),
      sprintf("%s %s %s", x@Dim[1], x@Dim[2], length(x@x))
    ),
    gzfile(file)
  )
  fwrite(
    x = summary(x),
    file = file,
    append = TRUE,
    sep = " ",
    row.names = FALSE,
    col.names = FALSE
  )
}


#' Export Seurat Object Data to 10X-Style Format with Optional Reductions
#'
#' This function exports the data from a Seurat object into a 10X Genomics-style format. The output includes files for the expression matrix, feature (gene) information, barcodes, metadata, UMAP (or other reductions), and variable features. These files are written in a compressed format where applicable.
#'
#' @param seu A Seurat object containing the data to be exported.
#' @param assay A character string indicating which assay to use from the Seurat object. Default is "RNA".
#' @param dir A character string specifying the directory where the output files will be saved. The directory must already exist.
#' @param get_reductions Logical, whether to include cell embeddings from reductions (e.g., UMAP, PCA, etc.) in the output. Default is TRUE.
#'
#' @details
#' The function creates several files in a subdirectory called \code{3file} within the specified directory:
#' \itemize{
#'   \item \code{matrix.mtx.gz}: A compressed MatrixMarket file containing the assay data (expression matrix).
#'   \item \code{features.tsv.gz}: A tab-separated file with feature (gene) information, including gene names.
#'   \item \code{barcodes.tsv.gz}: A tab-separated file with cell barcodes.
#'   \item \code{meta.csv}: A CSV file containing metadata from the Seurat object.
#'   \item \code{<reduction>_reduction.tsv.gz}: A compressed file with cell embeddings for each reduction (e.g., UMAP, PCA), if \code{get_reductions} is set to TRUE.
#'   \item \code{variablefeatures.tsv.gz}: A compressed file listing the variable features.
#' }
#'
#' If reductions (like UMAP or PCA) are present in the Seurat object and \code{get_reductions} is TRUE, the cell embeddings from each reduction will be written to separate files in the format \code{<reduction>_reduction.tsv.gz}.
#' If the UMAP or PCA embeddings are not found in the Seurat object and \code{get_reductions} is set to TRUE, the function will issue a warning but will still generate the other files.
#' The function will create the \code{3file} subdirectory within the specified directory if it doesn't exist.
#'
#' @importFrom Seurat GetAssayData Cells VariableFeatures
#' @importFrom utils write.csv
#' @importFrom R.utils gzip
#' @export
#' @return The function does not return a value. It writes several files as a side effect.
#'
#' @examples
#' \dontrun{
#' library(Seurat)
#' seu <- CreateSeuratObject(counts = matrix(rnorm(100), 10, 10))
#' make3file(seu, assay = "RNA", dir = "output_directory")
#' 
#' # Export Seurat object with reductions
#' make3file(seu, assay = "RNA", dir = "output_directory", get_reductions = TRUE)
#' 
#' # Export Seurat object without reductions
#' make3file(seu, assay = "RNA", dir = "output_directory", get_reductions = FALSE)
#' }
#'
#' @export
make3file <- function(seu, assay = "RNA", dir, get_reductions = TRUE) {
  # Check if the directory exists
  if (!file.exists(dir)) {
    stop("Must provide a valid directory.")
  }
  
  # Create the 3file subdirectory if it doesn't exist
  out_dir <- file.path(dir, "3file")
  if (!dir.exists(out_dir)) {
    dir.create(out_dir, recursive = TRUE)
  }
  
  # Write matrix.mtx.gz file
  mm <- file.path(out_dir, "matrix.mtx.gz")
  writeMMgz(GetAssayData(seu, assay = assay), mm)
  
  # Write features.tsv.gz file (gene information)
  genes <- data.frame(rownames(seu), rownames(seu), rep("Gene Expression", length(rownames(seu))))
  gz2 <- gzfile(file.path(out_dir, "features.tsv.gz"), "w")
  write.table(genes, gz2, sep = "\t", quote = FALSE, col.names = FALSE, row.names = FALSE)
  close(gz2)
  
  # Write barcodes.tsv.gz file (cell barcodes)
  gz3 <- gzfile(file.path(out_dir, "barcodes.tsv.gz"), "w")
  cb <- Cells(seu)
  writeLines(cb, gz3)
  close(gz3)
  
  # Write metadata to meta.csv
  meta <- file.path(out_dir, "meta.csv")
  write.csv(seu@meta.data, meta, quote = FALSE)
  
  # Write reductions if requested
  if (get_reductions) {
    reds <- names(seu@reductions)
    for (red in reds) {
      # Retrieve the reduction embeddings
      data <- seu@reductions[[red]]@cell.embeddings
      # Open gzipped reduction file
      gzr <- gzfile(file.path(out_dir, paste0(red, "_reduction.tsv.gz")), "w")
      # Write the reduction embeddings to the file
      write.table(data, gzr, sep = "\t", quote = FALSE, col.names = NA)
      close(gzr)
    }
  }
  
  # Write variable features to variablefeatures.tsv.gz
  gz4 <- gzfile(file.path(out_dir, "variablefeatures.tsv.gz"), "w")
  writeLines(VariableFeatures(seu), gz4)
  close(gz4)
}




